# -*- coding: utf-8 -*-
"""Energy Recommendation System

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11VrKZQrkzETIaKKvGGpaR0rPQRxvwDlF

**Understand Off-peak and Peak Energy Consumption Times**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""Data Loading and Cleaning"""

# Load the data without parsing dates
df = pd.read_csv('household_power_consumption.txt', sep=';', header=0, low_memory=False)

# Display the shape and first few rows of the dataframe
print(df.shape)
print(df.head())

# Identify and Print the number duplicate records
print("Number of Duplicated rows: ", df.duplicated().sum())

# Convert the date columns
df['datetime'] = pd.to_datetime(df['Date'] + ' ' + df['Time'], dayfirst=True)
df.set_index('datetime', inplace=True)

# Drop the original Date and Time columns if no longer needed
df.drop(columns=['Date', 'Time'], inplace=True)

# Drop duplicated rows
df.drop_duplicates(inplace=True)

# Verify the changes
print(df.shape)
print(df.head())
print("Number of duplicated rows after removal: ", df.duplicated().sum())

df = df.replace('?', np.nan)

# Convert variables to numeric, setting errors='coerce' to handle non-numeric data
df['Global_active_power'] = pd.to_numeric(df['Global_active_power'], errors='coerce')
df['Sub_metering_1'] = pd.to_numeric(df['Sub_metering_1'], errors='coerce')
df['Sub_metering_2'] = pd.to_numeric(df['Sub_metering_2'], errors='coerce')
df['Sub_metering_3'] = pd.to_numeric(df['Sub_metering_3'], errors='coerce')

# Check the count of missing/NaN values in each column
round((df.isnull().sum()/df.shape[0])*100,2)

# Drop rows with missing values for future datasets
df.dropna(inplace=True)

# Fill NaN values, if any, with the mean of the each column
df['Global_active_power'] = df['Global_active_power'].fillna(df['Global_active_power'].mean())
df['Sub_metering_1'] = df['Sub_metering_1'].fillna(df['Sub_metering_1'].mean())
df['Sub_metering_2'] = df['Sub_metering_2'].fillna(df['Sub_metering_2'].mean())
df['Sub_metering_3'] = df['Sub_metering_3'].fillna(df['Sub_metering_3'].mean())

# Display the count of NaN values in each column after filling
print("NaN values after filling:")
print(df.isnull().sum())

# Feature correlation to determine relevant features for Energy Consumption
correlation_matrix = df.corr()
print(correlation_matrix['Global_active_power'].sort_values(ascending=False))

# Identify and Display outliers of relevant features to energy consumption trends
plt.boxplot(df['Global_active_power'], vert=False)
plt.ylabel('Global_active_power')
plt.xlabel('Total Power consumed by household')
plt.title('Box Plot')
plt.show()

plt.boxplot(df['Sub_metering_1'], vert=False)
plt.ylabel('Sub_metering_1')
plt.xlabel('Active Energy for Kitchen')
plt.title('Box Plot')
plt.show()

plt.boxplot(df['Sub_metering_2'], vert=False)
plt.ylabel('Sub_metering_2')
plt.xlabel('Active Energy for laundry')
plt.title('Box Plot')
plt.show()

plt.boxplot(df['Sub_metering_3'], vert=False)
plt.ylabel('Sub_metering_3')
plt.xlabel('Active Energy for Climate control systems')
plt.title('Box Plot')
plt.show()

def remove_outliers(df, column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_limit = Q1 - 1.5 * IQR
    upper_limit = Q3 + 1.5 * IQR

    # Filter out the outliers
    mask = (df[column] >= lower_limit) & (df[column] <= upper_limit)
    return df[mask]

# Apply outlier removal for relevant columns
df = remove_outliers(df, 'Global_active_power')
print("After Global_active_power outlier removal:", df.shape)

df = remove_outliers(df, 'Sub_metering_1')
print("After Sub_metering_1 outlier removal:", df.shape)

df = remove_outliers(df, 'Sub_metering_2')
print("After Sub_metering_2 outlier removal:", df.shape)

plt.boxplot(df['Global_active_power'], vert=False)
plt.ylabel('Global_active_power')
plt.xlabel('Total Power consumed by household')
plt.title('Box Plot')
plt.show()

plt.boxplot(df['Sub_metering_1'], vert=False)
plt.ylabel('Sub_metering_1')
plt.xlabel('Active Energy for Kitchen')
plt.title('Box Plot')
plt.show()

plt.boxplot(df['Sub_metering_2'], vert=False)
plt.ylabel('Sub_metering_2')
plt.xlabel('Active Energy for laundry')
plt.title('Box Plot')
plt.show()

plt.boxplot(df['Sub_metering_3'], vert=False)
plt.ylabel('Sub_metering_3')
plt.xlabel('Active Energy for Climate control systems')
plt.title('Box Plot')
plt.show()

# Recalculate the correlation matrix with the cleaned data
correlation_matrix_cleaned = df.corr()
print(correlation_matrix_cleaned['Global_active_power'].sort_values(ascending=False))

"""Data Exploration and Feature Engineering"""

# Feature Engineering: Extract time-based features
df['hour'] = df.index.hour
df['day_of_week'] = df.index.dayofweek
df['month'] = df.index.month

# Separate weekday (0-4) and weekend (5-6) data
weekday_data = df[df['day_of_week'] < 5]
weekend_data = df[df['day_of_week'] >= 5]

# Group data by hour for weekdays and weekends
weekday_consumption = weekday_data.groupby('hour')['Global_active_power'].mean()
weekend_consumption = weekend_data.groupby('hour')['Global_active_power'].mean()

# Plot the average hourly consumption for weekdays
plt.figure(figsize=(10,5))
weekday_consumption.plot(kind='line', label='Weekdays', color='blue')
plt.title('Average Hourly Global Active Power on Weekdays')
plt.xlabel('Hour of the Day')
plt.ylabel('Global Active Power (kilowatts)')
plt.grid(True)
plt.show()

# Plot the average hourly consumption for weekends
plt.figure(figsize=(10,5))
weekend_consumption.plot(kind='line', label='Weekends', color='green')
plt.title('Average Hourly Global Active Power on Weekends')
plt.xlabel('Hour of the Day')
plt.ylabel('Global Active Power (kilowatts)')
plt.grid(True)
plt.show()

"""Normalising/Scaling"""

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
df[[ 'Global_active_power', 'Sub_metering_1', 'Sub_metering_2', 'Sub_metering_3']] = scaler.fit_transform(df[[ 'Global_active_power','Sub_metering_1', 'Sub_metering_2', 'Sub_metering_3']])